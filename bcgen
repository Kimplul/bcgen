#!/usr/bin/env python3

import sys
import pathlib

bcode_header_fmt = '''
#ifndef BCGEN_BCODE_H
#define BCGEN_BCODE_H

#include <stdio.h>
#include <stddef.h>

struct run_state;

typedef float fbcval_t;
typedef double dbcval_t;
typedef size_t bcreloc_t;
typedef {self.ubcval_type} ubcval_t;
typedef {self.sbcval_type} sbcval_t;
typedef void (*bcall_t)({self.params});

typedef union {{
	ubcval_t r;
	sbcval_t s;
	fbcval_t f;
	dbcval_t d;
}} bcval_t;

struct run_state {{
	void* (*op);
        bcval_t *imm[{self.i}];
}};

struct compile_state {{
	struct run_state s;
	size_t size;
	size_t pc;
}};

{self.select_header}

void run(struct compile_state *cs, ubcval_t ri[{self.r}], dbcval_t fi[{self.f}]);
void init(struct compile_state *cs);
void end(struct compile_state *cs);
void destroy(struct compile_state *cs);

bcval_t label(struct compile_state *cs);
void patch(struct compile_state *cs, bcreloc_t reloc, size_t i, bcval_t imm);

#endif /* BCGEN_BCODE_H */
'''

bcode_src_fmt = '''
#include <stdlib.h>
#include <assert.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#include "{self.name}.h"

#if __has_attribute(musttail)
#define __musttail __attribute__((musttail))
#else
#define __musttail
#endif

{self.head}

static void append(struct compile_state *cs, bcall_t op,
                    size_t n, bcval_t imm[])
{{
	if (cs->pc == cs->size) {{
		cs->size *= 2;
		/* better memory checks could be a good idea */
		cs->s.op = realloc(cs->s.op, cs->size * sizeof(*cs->s.op));
		assert(cs->s.op);

                for (size_t i = 0; i < {self.i}; ++i) {{
                    cs->s.imm[i] = realloc(cs->s.imm[i],
                        cs->size * sizeof(*cs->s.imm[i]));
                    assert(cs->s.imm[i]);
                }}
	}}

	struct run_state *s = &cs->s;
	s->op[cs->pc] = op;
        for (size_t i = 0; i < n; ++i)
	    s->imm[i][cs->pc] = imm[i];

	cs->pc++;
}}

#define RELOC cs->pc

#define IMM(i)  s.imm[(i)][pc].r
#define SIMM(i) s.imm[(i)][pc].s
#define FIMM(i) s.imm[(i)][pc].f
#define DIMM(i) s.imm[(i)][pc].d

#define IMM0  IMM(0)
#define SIMM0 SIMM(0)
#define FIMM0 FIMM(0)
#define DIMM0 DIMM(0)

#define NEXT_INSN() __musttail return ((bcall_t)s.op[++pc])({self.args})
#define JUMP(i) __musttail return ((bcall_t)s.op[pc = (i)])({self.args})

{self.macro}
{self.ops}
{self.select}


void run(struct compile_state *cs,
    ubcval_t ri[{self.r}],
    dbcval_t fi[{self.f}])
{{
        // silence warnings if zero registers defined
        (void)ri;
        (void)fi;

	const struct run_state s = cs->s;
        return ((bcall_t)s.op[0])({self.init_args});
}}

void init(struct compile_state *cs)
{{
	cs->size = 16;

        for (size_t i = 0; i < {self.i}; ++i) {{
            cs->s.imm[i] = malloc(cs->size * sizeof(*cs->s.imm));
            assert(cs->s.imm[i]);
        }}

	cs->s.op = malloc(cs->size * sizeof(*cs->s.op));
	assert(cs->s.op);

	cs->pc = 0;
}}

void bcend({self.params})
{{
    (void)(s);
    (void)(pc);
    (void)(ri);
    (void)(fi);
    {self.end_copy}
    return;
}}

void end(struct compile_state *cs)
{{
	append(cs, bcend, 0, NULL);
}}

bcval_t label(struct compile_state *cs)
{{
	return (bcval_t){{.r = cs->pc}};
}}

void patch(struct compile_state *cs, bcreloc_t reloc, size_t i, bcval_t imm)
{{
	cs->s.imm[i][reloc] = imm;
}}

void destroy(struct compile_state *cs)
{{
	free(cs->s.op);

        for (size_t i = 0; i < {self.i}; ++i)
	    free(cs->s.imm[i]);
}}
'''

def check_fmt(fmt, imms):
    # todo: should sign value be encoded in the registers?
    assert(len(fmt) == 5 + imms)
    assert(fmt[0] == '_' or fmt[0] == 'r')

    for i in range(1, 5):
        c = fmt[i]
        assert(c == 'R' or c == 'F' or c == '_')

    for i in range(5, 5 + imms):
        c = fmt[i]
        assert(c == '_' or c == 'I' or c == 'D' or c == 'S')

def param(fmt, i):
    c = fmt[i + 1]
    return c + str(i)

def gen_fname(name, r0, r1, r2, r3):
    return '{}_{}{}{}{}'.format(name, r0, r1, r2, r3)

def num_imms(fmt):
    n = 0
    for p in fmt[5:]:
        if p == 'I' or p == 'S' or p == 'D':
            n += 1

    return n

def gen_hash(fmt):
    n = 0
    i = 0
    r = "0"
    for p in fmt[1:]:
        if p == 'R' or p == 'F':
            r += ' + (a' + str(n) + ' << (' + str(i) + ' * 8))'
            n += 1
            i += 1

        elif p == '_':
            i += 1
            continue

        else:
            break

    return r


def gen_select_params(fmt):
    n = 0
    r = ""
    for p in fmt[1:]:
        if p == 'R' or p == 'F':
            # todo: could be useful to have different types for general purpose
            # registers and floating point registers, might avoid bugs that
            # would otherwise be pretty annoying to track down.
            r += ', size_t a' + str(n)
            n += 1

        elif p == '_':
            continue

        else:
            break

    n = 0
    i = ""
    for p in fmt[5:]:
        if p == 'I':
            i += ', ubcval_t i' + str(n)
            n += 1
        elif p == 'S':
            i = ', sbcval_t i' + str(n)
            n += 1
        elif p == 'D':
            i = ', fbcval_t i' + str(n)
            n += 1

    return '(struct compile_state *cs' + r + i + ')'

def gen_select_signature(name, fmt):
    ret = 'void '
    if fmt[0] == 'r':
        ret = 'bcreloc_t '

    n = 'select_' + name
    p = gen_select_params(fmt)
    return ret + n + p

def gen_cond(r, i):
    if r == '':
        return ' + 0'

    return ' + (' + r[1:] + ' << (' + str(i) + ' * 8))'


def gen_params(r, f):
    # pc and run state most important to place in registers
    pc = ["const struct run_state s, size_t pc"]

    # general purpose registers after that
    gregs = [', ubcval_t r' + str(i)
                for i in range(r)]

    # floating point after that
    fregs = [', dbcval_t f' + str(i)
                for i in range(f)]

    # return values last, as they can perfectly well be passed on the stack,
    # they're only accessed at the end of an execution
    rgregs = [', ubcval_t ri[' + str(r) + ']']
    rfregs = [', dbcval_t fi[' + str(f) + ']']

    params = pc + gregs + fregs + rgregs + rfregs
    return ''.join(params)

def gen_args(r, f):
    pc = ["s, pc"]
    gregs = [', r' + str(i)
                for i in range(r)]

    fregs = [', f' + str(i)
                for i in range(f)]

    rgregs = [', ri']
    rfregs = [', fi']

    args = pc + gregs + fregs + rgregs + rfregs
    return ''.join(args)


def gen_init_args(r, f):
    pc = ["s, 0"]
    gregs = [', ri[' + str(i) + ']'
                for i in range(r)]

    fregs = [', fi[' + str(i) + ']'
                for i in range(f)]

    rgregs = [', ri']
    rfregs = [', fi']

    init_args = pc + gregs + fregs + rgregs + rfregs
    return ''.join(init_args)

def gen_end_copy(r, f):
    gregs = ['ri[' + str(i) + '] = r' + str(i) + ';\n'
                for i in range(r)]

    fregs = ['fi[' + str(i) + '] = f' + str(i) + ';\n'
                for i in range(f)]

    end_copy = gregs + fregs
    return ''.join(end_copy)


class BCGen:
    def __init__(self, r = 3, f = 3, i = 1,
            ubcval_type = 'unsigned long',
            sbcval_type = 'signed long',
            extra='', head=''):

        self.r = r
        self.f = f
        self.i = i

        self.ubcval_type = ubcval_type
        self.sbcval_type = sbcval_type

        self.extra = extra
        self.head = head

        self.ops = []
        self.rregs = []
        self.macro = []
        self.static = []
        self.select = []
        self.select_header = []

        self.args = gen_args(r, f)
        self.params = gen_params(r, f)
        self.init_args = gen_init_args(r, f)
        self.end_copy = gen_end_copy(r, f)

    def gen_exec_instance(self, name, r0, r1, r2, r3):
        fn = gen_fname(name, r0, r1, r2, r3)
        macro = '{}({}, {}, {}, {}); '.format(name.upper(), r0, r1, r2, r3)
        op = "static void " + fn + "(" + self.params + ")\n"
        body = "{\n" + macro + "NEXT_INSN();\n}\n"
        self.ops.append(op + body)

    def gen_select_instance(self, name, r0, r1, r2, r3):
        c0 = gen_cond(r0, 0)
        c1 = gen_cond(r1, 1)
        c2 = gen_cond(r2, 2)
        c3 = gen_cond(r3, 3)
        cond = c0 + c1 + c2 + c3
        action = 'fn = ' + gen_fname(name, r0, r1, r2, r3) + ';'
        self.select.append('case ' + cond + ': {' + action + '}; break;\n')

    def gen_macro(self, name, fmt, body):
        name = name.upper()

        p0 = param(fmt, 0)
        p1 = param(fmt, 1)
        p2 = param(fmt, 2)
        p3 = param(fmt, 3)

        macro = '#define {}({}, {}, {}, {}) {}\n'.format(
                name, p0, p1, p2, p3, body.replace('\n', ''))

        self.macro.append(macro)

    def place(self, fmt, i):
        c = fmt[i + 1]
        if c == 'R':
            return ['r' + str(i) for i in range(self.r)]

        if c == 'F':
            return ['f' + str(i) for i in range(self.f)]

        return [""]

    def gen_ops(self, name, fmt):
        for r0 in self.place(fmt, 0):
            for r1 in self.place(fmt, 1):
                for r2 in self.place(fmt, 2):
                    for r3 in self.place(fmt, 3):
                        self.gen_exec_instance(name, r0, r1, r2, r3)

    def gen_select(self, name, fmt):
        sign = gen_select_signature(name, fmt)
        self.select_header.append(sign + ';\n')

        self.select.append(sign + '\n')
        self.select.append('{\nbcall_t fn = NULL;\n')
        if fmt[0] == 'r':
            self.select.append('bcreloc_t reloc = RELOC;\n')

        calc_hash = gen_hash(fmt);
        self.select.append('unsigned long hash = ' + calc_hash + ';\n');
        self.select.append('switch (hash) {\n')

        # we could potentially just calculate the wanted label directly and skip
        # the huge number of if statements, potentially giving us a slight
        # compile time speedup
        for r0 in self.place(fmt, 0):
            for r1 in self.place(fmt, 1):
                for r2 in self.place(fmt, 2):
                    for r3 in self.place(fmt, 3):
                        self.gen_select_instance(name, r0, r1, r2, r3)

        self.select.append('default: fprintf(stderr,' +
                           '"invalid args to ' + name + '"); abort(); }\n')

        n = num_imms(fmt)
        imms = "NULL"
        if n > 0:
            s = '{i' + str(0) + '}'
            for i in range(n - 1):
                s += ', {i' + str(i) + '}'

            self.select.append('bcval_t imms[{n}] = {{{s}}};\n'.format(n=n, s=s))
            imms = "imms"


        self.select.append('append(cs, fn, {n}, {imms});\n'.format(n=n, imms=imms))

        if fmt[0] == 'r':
            self.select.append('return reloc;\n')

        self.select.append('}\n')


    def rule(self, name, fmt, body):
        check_fmt(fmt, self.i)
        self.gen_macro(name, fmt, body)
        self.gen_select(name, fmt)
        self.gen_ops(name, fmt)

    def write(self, name='bcode'):

        with open(name + '.h', 'w') as f:
            self.select_header = ''.join(self.select_header)
            f.write(bcode_header_fmt.format(self=self))

        with open(name + '.c', 'w') as f:
            # join arrays into single strings
            self.name = name
            self.head = ''.join(self.head)
            self.select = ''.join(self.select)
            self.macro = ''.join(self.macro)
            self.ops = ''.join(self.ops)

            f.write(bcode_src_fmt.format(self=self))

assert(len(sys.argv) == 2)
exec(open(sys.argv[1]).read())
